package nl.avans.wordcrex.data;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import javax.sql.DataSource;
import java.sql.*;

public class Database {
    private final DataSource source;

    private Connection connection;
    private int queries = 0;

    public Database(String config) {
        var hikari = new HikariConfig("/db/" + config + ".properties");
        hikari.setMaximumPoolSize(2);

        this.source = new HikariDataSource(hikari);
    }

    private Connection getConnection() throws SQLException {
        if (this.connection != null) {
            return this.connection;
        }

        return this.source.getConnection();
    }

    private void executeStatement(String sql, SqlConsumer<PreparedStatement> execute, int autoGeneratedKeys) throws SQLException {
        var connection = this.getConnection();

        try (var statement = connection.prepareStatement(sql, autoGeneratedKeys)) {
            execute.accept(statement);
        } catch (SQLException e) {
            this.rollback();
        } finally {
            this.queries++;
            if (connection != this.connection) {
                connection.close();
            }
        }
    }

    public void start() {
        System.err.println("Starting transaction...");

        try {
            this.connection = this.getConnection();
            this.connection.setAutoCommit(false);
        } catch (SQLException e) {
            System.err.println("Failed to create transaction");
        }
    }

    public int select(String sql, SqlConsumer<ResultSet> consumer) {
        return this.select(sql, (statement) -> {}, consumer);
    }

    public int select(String sql, SqlConsumer<PreparedStatement> prepare, SqlConsumer<ResultSet> consumer) {
        var ref = new Object() {
            int selected;
        };

        try {
            this.executeStatement(sql, (statement) -> {
                prepare.accept(statement);

                try (var result = statement.executeQuery()) {
                    while (result.next()) {
                        consumer.accept(result);
                        ref.selected++;
                    }
                }
            }, Statement.NO_GENERATED_KEYS);
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return ref.selected;
    }

    public int update(String sql, SqlConsumer<PreparedStatement> prepare) {
        var ref = new Object() {
            int updated;
        };

        try {
            this.executeStatement(sql, (statement) -> {
                prepare.accept(statement);

                ref.updated = statement.executeUpdate();
            }, Statement.NO_GENERATED_KEYS);
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return ref.updated;
    }

    public int insert(String sql, SqlConsumer<PreparedStatement> prepare) {
        var ref = new Object() {
            int created;
        };

        try {
            this.executeStatement(sql, (statement) -> {
                prepare.accept(statement);

                var created = statement.executeUpdate();

                if (created == 0) {
                    ref.created = -1;

                    return;
                }

                try (var result = statement.getGeneratedKeys()) {
                    if (!result.next()) {
                        ref.created = 0;

                        return;
                    }

                    ref.created = result.getInt(1);
                }
            }, Statement.RETURN_GENERATED_KEYS);
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return ref.created;
    }

    public void commit() {
        if (this.connection == null) {
            return;
        }

        System.err.println("Committing transaction...");

        try {
            this.connection.commit();
            this.connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
            System.err.println("Failed to commit transaction");
        } finally {
            this.connection = null;
        }
    }

    public void rollback() {
        if (this.connection == null) {
            return;
        }

        System.err.println("Rolling back last transaction...");

        try {
            this.connection.rollback();
            this.connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
            System.err.println("Failed to rollback transaction");
        } finally {
            this.connection = null;
        }
    }

    public int flush() {
        var queries = this.queries;

        this.queries = 0;

        return queries;
    }
}
